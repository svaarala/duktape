=proto
void *duk_get_heapptr(duk_context *ctx, duk_idx_t index);

=stack
[ ... val! ... ]

=summary
<p>Get a borrowed <code>void *</code> reference to a Duktape heap allocated
value (object, buffer, string) at <code>index</code>.  Return <code>NULL</code>
if the index is invalid or the target value is not heap allocated.
The returned pointer must not be interpreted or dereferenced, but
<code><a href="#duk_push_heapptr">duk_push_heapptr()</a></code> can be used
to push the original value into the value stack later.</p>

<p>The returned void pointer is only valid while the original value is
reachable from a garbage collection point of view.  If this is not the case,
it is memory unsafe to use
<code><a href="#duk_push_heapptr">duk_push_heapptr()</a></code>.</p>

=example
duk_context *new_ctx;
void *ptr;

duk_eval_string(ctx, "({ foo: 'bar' })");
ptr = duk_get_heapptr(ctx, -1);

/* The original value must remain reachable for Duktape up to a future
 * duk_push_heapptr().  Here we just write it to the global object, but
 * it could also be a value stack somewhere, a stash object, etc.
 */
duk_put_global_string(ctx, "ref");

/* Later, assuming the original value has been reachable all the way
 * to here:
 */

duk_push_heapptr(ctx, ptr);
duk_get_prop_string(ctx, -1, "foo");
printf("obj.foo: %s\n", duk_safe_to_string(ctx, -1));  /* prints 'bar' */

=tags
stack
borrowed

=seealso
duk_require_heapptr
duk_push_heapptr

=introduced
1.1.0
